Exercise from class slides. Note that during the class we made both IStudent and ITeacher implement IUser (`internal interface IStudent: IUser` and `internal interface ITeacher: IUser` respectively) - this is completely legal, but in our case redundant (Student and Teacher inherit User), and most of the time a better way would to just make the class implement all the interfaces it needs to conform to - this would mean something like `internal class Student: User, IUser, IStudent`. The reason for this is that a hierarchy of interfaces hides what the "child" interface would force without going down the interface hierarchy, because the base interface won't force the "child" interface to declare (or implement, no implementation in interfaces) the base methods, and this makes visibility and navigation through the code harder. Additionally, unless you are careful, there could be some conflicts in case both the base and "child" interface have matching members.